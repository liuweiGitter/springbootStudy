读取字符文件时，需要通过字节缓冲转换为字符缓冲，转换按照实际的字符编码格式进行字符解码和输出

每次读出的一组字节缓冲，可能并不会全部被转为字符，这会带来大问题
这和编码算法有关，GB算法会将2个字节转为1个字符，可以完整转换所有的字节
UTF算法则不一样，中文会占据2个字节，但英文等只占据1个字节，这将导致一定数量的字节可能不能完整转换为字符
举例来说，每次读取1024字节，第1023字节为换行符，占据1个字节，第1024-1025字节为中文，占据2个字节
CharsetDecoder会读取字节缓冲并解码输出到字符缓冲，decoder只会读取到可以转换为字符的字节
也就是说，字节缓冲只会被读取到第1023字节，1024字节本次是不读取的
ByteBuffer提供了2个重要的方法来清理缓存
compact()方法用以重排字节缓冲区，将清空所有已读的字节，并将本次未读到的字节排入缓冲区队首，以待和下次缓冲字节一起读取
clear()方法则会清空所有缓冲区
对于GB算法，只要设置缓冲区长度为偶数，实际上，每次转换都是读完所有字节的，clear方法就可以
对于UTF算法，即使设置缓冲区长度为偶数，每次转换可能不会读完所有字节，需要使用compact方法
为兼容所有字符集的解码，统一使用compact方法清理字节缓冲区

注意1：如果第一个字节不是字符的完整起点，则整段字节都会被丢弃
因此，对于UTF算法，如果使用clear方法，则1025-2048字节的所有内容将被丢弃

注意2：UTF算法还将导致2n个字节转换为超过n个字符的结果(因为一些字符是单字节的)