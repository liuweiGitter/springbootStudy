引用自https://segmentfault.com/a/1190000017128263?utm_source=tag-newest并做了部分改动

为什么要使用Netty？
使用Netty，你可以非常方便地实现自己所需协议的服务器，如HTTP、FTP、UDP、各种代理服务器等
Netty作为高性能的基础通信组件，本身提供了TCP/UDP和HTTP协议栈，且支持方便地定制和开发私有协议栈

【传统的BIO模式服务器】
传统处理http的服务器，使用BIO，在接收到一个连接请求后，会启动一个新的线程去处理该请求
主线程中：
客户端监听(Listen)时，Accept是阻塞的，只有新连接来了(新连接会启动一个新的子线程去处理请求)，Accept才会返回，主线程才能继续
子线程中：
读写socket时，Read是阻塞的，只有请求消息来了，Read才能返回，子线程才能继续处理
读写socket时，Write是阻塞的，只有客户端把消息收了，Write才能返回，子线程才能继续处理

BIO模式下，主线程以及所有子线程的所有socket操作都是阻塞的，阻塞期间，这些线程占用着系统的资源不释放，但却什么事也不干
在高并发的环境下，线程数量会比较多，系统运行效率会大幅下降
★注：BIO的效率太低，在tomcat7及以上版本中已被弃用，详参《Tomcat连接的三种运行模式(BIO+NIO+APR)》

【NIO模式服务器】
IO可以多路复用，而不需要多线程的IO，由此出现了NIO
IO多路复用功能由操作系统提供，早期这个操作系统调用的名字是select，但是性能低下，后来渐渐演化成了Linux下的epoll和Mac里的kqueue
Java的NIO基于Linux的epoll，但使用起来很不方便，而且还存在空轮询问题(更新的版本也许会解决这个问题)

NIO是单线程非阻塞的多路IO
NIO用一个线程(称为NIO线程)就可以把监听、读、写、请求处理的逻辑等所有(大量)请求的全部操作全干了
非阻塞是由事件机制实现的，NIO轮询所有请求的事件，如果所有的请求都没有事件就绪，则线程休眠，醒来后进行下一次轮询
如果有请求事件就绪，则在NIO线程中遍历处理这些事件

NIO单线程可以处理所有请求，但在高并发时，应开出多个NIO线程，每个线程处理一部分请求，以提高请求处理效率
tomcat的nio模式支持线程池的设置，参见《Tomcat连接的三种运行模式(BIO+NIO+APR)》

Netty就是基于Java NIO技术封装和优化的一套框架，对外提供了一套易于操作的接口
Netty是目前Java网络编程最主流的框架之一，并发性能以及安全性优异

【Netty的应用实例】
系统拆分之后分布式部署时，各个节点之间需要高性能的远程服务调用框架进行服务调用，Netty作为异步高性能的通信框架，往往作为基础通信组件被这些RPC框架使用
互联网领域，阿里分布式RPC框架Dubbo使用Dubbo协议进行节点间通信，Dubbo协议默认使用Netty作为基础通信组件
另外，阿里消息中间件RocketMQ的消息生产者和消息消费者之间，也采用Netty进行高性能的异步通信
大数据领域，Hadoop的高性能通信和序列化组件Avro，其RPC框架默认使用Netty进行跨节点通信

