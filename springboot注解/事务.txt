【事务的特性】ACID
原子性（Atomicity）：
	事务是一个由一系列动作组成的原子操作，事务的原子性确保事务内的这些动作要么全部完成，要么全部回滚。
	这是由事务本身提供的能力。
一致性（Consistency）：
	一旦事务完成，不管成功还是失败，系统必须确保它所建模的业务处于数据一致的状态，而不会是部分完成部分失败。
	这是由业务代码提供的能力。
隔离性（Isolation）：
	在多个事务同时读写同一个数据时，每个事务的读写操作都应该与其他事务隔离开来，防止数据脏读脏写。
	这是由事务本身提供的能力，但需要在业务中合理的选择隔离级别。
持久性（Durability）：
	一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被持久化到数据库中。
	这是由业务代码提供的能力。
	

【Spring事务的配置方式】
Spring支持编程式事务管理以及声明式事务管理两种方式。

编程式事务管理是侵入性事务管理，即在业务代码中编写事务代码，不建议这么做

声明式事务管理属于无侵入性事务管理，在配置文件中做相关的事务规则声明或者在业务代码方法上添加注解即可实现
其本质是AOP，在方法前后进行拦截，在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚。
声明式事务管理的粒度是方法级别。

【事务的传播机制】
一个事务方法里面调用了另外一个事务方法，由此产生了事务嵌套问题
事务的传播属性决定了事务嵌套场景下，内外层事务的执行逻辑。

常用的事务传播机制如下：

PROPAGATION_REQUIRED
	Spring默认的传播机制，能满足绝大部分业务需求。
	>>>本方法需要一个事务，尽量不用新事务。
	如果外层有事务，则当前事务加入到外层事务，一块提交，一块回滚。
	如果外层没有事务，新建一个事务执行。
	===外层有事务时，共用同一个事务，与外层事务一起提交，一起回滚，任何一个地方有异常，会全部回滚
PROPAGATION_REQUES_NEW
	>>>本方法需要一个事务，且必须是新事务。
	当前方法每次都会新开启一个事务。
	如果外层有事务，会把外层事务挂起，在当前事务执行完毕后，恢复外层事务的执行。
	如果外层没有事务，执行当前新开启的事务即可。
	===外层也有事务时，与外层事务完全独立，各自提交，各自回滚，各自异常互不影响
	===不过，如果内层异常没有被事务捕捉到而抛出到外层，外层也会被回滚
PROPAGATION_SUPPORT
	>>>本方法是否在事务中，完全依赖于外层是否有事务。
	如果外层有事务，则加入外层事务。
	如果外层没有事务，则直接使用非事务方式执行。
	===外层有事务时，共用同一个事务，与外层事务一起提交，一起回滚，任何一个地方有异常，会全部回滚
PROPAGATION_NOT_SUPPORT
	>>>本方法不使用事务，且不支持事务，也就是说即使有异常也不会回滚当前的代码
	注意，本事务传播类型并不等价于不添加事务注解，而是更进一步，强制不回滚当前代码
	===外层有事务时，挂起外层事务，执行完当前代码后，恢复外层事务，当前方法有异常也不回滚，任何一个地方有异常，外层事务都回滚
	===外层没有事务时，当前方法有异常也不回滚
PROPAGATION_NEVER
	>>>本方法不使用事务，且所有外层也不允许出现事务
	===外层有事务时，本方法抛出异常
PROPAGATION_MANDATORY
	>>>本方法使用外层的事务，外层必须有事务
	===外层没有事务时，本方法抛出异常
PROPAGATION_NESTED
	>>>本方法开启一个新事务，无论外层是否有事务
	===外层没有事务时，本方法代码执行时取得一个savepoint，如果本方法异常，将回滚到此 savepoint
	===外层有事务时，挂起外层事务，本方法代码执行时取得一个savepoint，如果本方法异常，将回滚到此 savepoint，而外层将全部回滚

☆☆☆☆☆注：PROPAGATION_NESTED是Spring所提供的一个特殊变量，由于需要Savepoint操作，
它要求使用如DataSourceTransactionManager等实现JDBC 3.0 Savepoint API的事务管理器提供嵌套事务行为
关于DataSourceTransactionManager以及PROPAGATION_NESTED的用法，资料尚不完整，不详述

【事务的隔离级别】
事务的隔离级别定义一个事务对数据读写操作的正确性可能受其它并发务事务影响的程度

当多个事务同时读写同一个数据时，即并发读写同一数据时，可能会产生脏读、不可重复读、幻读等问题

说明1：
没有两个事务会在绝对的同一个时间点读写同一条数据，所谓同时，是一个时间段的概念
在事务开始到结束之间的时间段，可称为事务活动期
如果两个事务的活动期有时间段交叉，且交叉时间段都有读写同一条数据，则认为两个事务同时读写了同一条数据

说明2：
所谓并发，指的是两个事务同时读写了同一条数据的事实性
即使两个事务活动期有交叉，但不读写同一个数据，也不是并发

-------------------------------------------------------------
脏读（Dirty read）
在事务A读取了事务B修改但尚未提交的数据β时：
1.如果这些改变在稍后被回滚了，那么事务A读取的数据就会是无效的。
2.如果事务A也对数据进行修改并先于事务B提交，那么数据修改的结果也会是错误的。
举例来说，初始β=5，B读，B+1==6，A读缓存，A+1==7，A先提交，β=7，B再提交，β=6，结果，实际应为7但脏写为6

以上2种情况下即发生了脏读

脏读是由于读缓存造成的

-------------------------------------------------------------
不可重复读（Nonrepeatable read）
事务A执行两次或以上相同的查询时：
1.如果另一个事务B在事务A每次查询间隙修改了数据，则事务A每次查询结果都不相同
举例来说
I. 初始β=5，A读5，B提交6，A再读6

以上1种情况下即发生了不可重复读

-------------------------------------------------------------
幻读（Phantom reads）
事务A执行两次或以上相同的查询时：
1.如果另一个事务B在事务A每次查询间隙新增或删除了数据，则事务A每次查询的数据数量都不相同
举例来说
I. 初始总数据量为5，A读5，B新增/删除一条数据，A再读6/4
II. 初始，A读一条数据β，B删除β，A再读为空

以上1种情况下即发生了幻读

幻读和不可重复读相似，幻读是由于数据的增删造成，而不可重复读则是由于数据的修改造成


在理想状态下，事务之间将完全隔离，从而可以防止所有这些问题的发生。
然而，完全隔离要求事务相互等待来完成工作，会影响并发性能，因为隔离经常涉及到锁定在数据库中的记录（甚至有时是锁表）。
因此，可以根据具体的业务场景选择不同的隔离级别，以兼顾安全和效率

-------------------------------------------------------------
spring事务的隔离级别的类型如下
ISOLATION_DEFAULT
	使用后端数据库默认的隔离级别，这也是spring的默认隔离级别
ISOLATION_READ_UNCOMMITTED
	读未提交
	允许读取并发事务尚未提交的更改。
	可能导致脏读、幻读或不可重复读。
ISOLATION_READ_COMMITTED
	读已提交
	Oracle 默认级别，允许读取并发事务提交的数据。
	可防止脏读，但不能避免幻读和不可重复读。
ISOLATION_REPEATABLE_READ
	可重复读
	Mysql 默认级别，对相同数据的多次读取结果是一致的，除非数据被当前事务本身改变。
	可防止脏读和不可重复读，但不能避免幻读。
ISOLATION_SERIALIZABLE
	串行读
	完全服从ACID的最高等级的隔离级别，确保不发生脏读、不可重复读和幻读。
	这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。

-------------------------------------------------------------
隔离级别的选择建议
如果确保不会有并发事务，则可使用ISOLATION_READ_UNCOMMITTED

一般情况下，对于可能会存在并发事务的场景
如果事务中不会重复读取同一条数据，则可使用ISOLATION_READ_COMMITTED
如果事务中需要重复读取同一条数据，且确定并发事务[不存在数据增删 or 数据增删不影响结果]，则可使用ISOLATION_REPEATABLE_READ
如果事务中需要重复读取同一条数据，且确定并发事务[可能存在影响结果的数据增删]，则需要使用ISOLATION_SERIALIZABLE

通常来说，业务场景大多是可能存在并发事务但不会在一个事务中重复读取同一条数据的，因此默认事务隔离级别选择ISOLATION_READ_COMMITTED即可
对于spring来说，默认级别至少就是ISOLATION_READ_COMMITTED，因此，spring保持默认级别即可

【事务的只读性】
如果数据库认为一个事务执行读操作，那么该数据库就可以应用那些它认为合适的优化措施，比如轻量级锁等，提高并发效率。
在只读场景下，可以把一个事务声明为只读，以向数据库传递只读信号

实际上，绝大多数只读场景是不需要添加事务的

spring事务默认是读写的

【事务的超时】
如果一个事务的级别在ISOLATION_READ_COMMITTED及以上，且事务又不是只读的，则这个事务会涉及对数据库 行或表 的锁定
如果这个事务的运行时间很长，则会长期锁定数据库资源

这类长耗时重锁事务应该设置超时时间，以及时释放资源
事务的即使从事务开启之后(注解方法开始的第一行代码)算起，在事务超时后，会自动回滚

spring事务默认是不超时的

【事务的提交和回滚】
org.springframework.transaction.interceptor.DefaultTransactionAttribute类中定义了事务注解默认的回滚异常类型：
    public boolean rollbackOn(Throwable ex) {
        return ex instanceof RuntimeException || ex instanceof Error;
    }
	
可以看到，事务默认会处理(即捕获到以后就回滚)所有运行时异常RuntimeException和Error错误，而不会处理所有的非运行时异常
运行时异常不需要try-catch捕获或者throw处理，事务可以直接捕获

非运行时异常(RuntimeException之外的所有异常)，需要try-catch捕获或者throw处理
对于事务中的非运行时异常，如果程序自己捕获处理而不是向外抛出，则事务是无法捕获到的(事务本身是一层AOP代理)
即使程序向外抛出异常，事务能捕获到但不会处理，除非事务特地声明要处理这些异常

当声明需要处理异常时，会追加到异常处理队列中
举例来说，声明需要处理IOException异常，则实际会处理IOException+(RuntimeException+Error)
关于哪些异常会引起回滚，参见org.springframework.transaction.interceptor.RuleBasedTransactionAttribute
该类继承了DefaultTransactionAttribute，并重写了其rollbackOn(Throwable ex)方法，判断是否回滚的具体逻辑在该方法中

由于所有的异常都是Exception的子类，因此，如果事务中存在非运行时异常，除了可以声明具体的异常外，还可以声明处理Exception类型异常
一般不建议直接声明Exception类型异常


默认情况下，事务内代码无异常无错误时会提交
有运行时异常或者Error错误时会回滚并内屏蔽异常
有非运行时异常时不回滚且视具体异常处理方式来决定是否对外抛出异常

☆☆☆☆☆事务的异常处理原则是☆☆☆☆☆
1.事务中不存在非运行时异常时，使用事务的默认行为，不需要配置 异常回滚处理 参数
2.事务中存在非运行时异常时，不能try-catch，或者try-catch后需要再次抛出，而且需要配置 异常回滚处理 参数，声明需要处理具体的，或整个Exception类型异常

哪些常见的异常属于非运行时异常？
IOException


说明：
事务的回滚通常会全部回滚，具体要看传播机制，有些机制会部分回滚到savepoint

【事务注解配置demo】
propagation  传播机制，默认Propagation.REQUIRED，取值范围
	REQUIRED(0),
    SUPPORTS(1),
    MANDATORY(2),
    REQUIRES_NEW(3),
    NOT_SUPPORTED(4),
    NEVER(5),
    NESTED(6);
isolation  隔离级别，默认Isolation.DEFAULT，取值范围
    DEFAULT(-1),
    READ_UNCOMMITTED(1),
    READ_COMMITTED(2),
    REPEATABLE_READ(4),
    SERIALIZABLE(8);
timeout  超时时间秒数，默认-1，即不超时
readOnly  是否只读事务，默认false
rollbackFor  遇到哪些异常回滚，默认{}，实际会取RuntimeException+Error
noRollbackFor  遇到哪些异常不回滚，默认{}

注1：一个异常是否会真的引起回滚，和rollbackFor以及noRollbackFor都有关系，具体参见RuleBasedTransactionAttribute的rollbackOn(Throwable ex)方法
结论是
一个Error错误任何时候都会回滚
一个RuntimeException异常A，当且仅当，noRollbackFor为空，或者noRollbackFor不包含A，时，会回滚
一个非RuntimeException异常B，当且仅当，rollbackFor包含B，且noRollbackFor不包含B，时，会回滚

注2：一个异常如果没有回滚，则多数情况下不能保证事务的ACID特性，需要谨慎设计事务的rollbackFor异常类型
通常来说，我们可以设计事务处理所有可能的异常类型，这样不会有任何后顾之忧
但，有时候我们也希望部分操作持久化，即存在savepoint，这时候我们希望能部分回滚，不过这和rollbackFor没有关系，而是可以使用PROPAGATION_NESTED传播机制

注3：事务超时也会引起回滚，能走到事务超时，事务本身(即AOP层)一定是(还)没有捕获到异常的



默认配置
@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT, 
	timeout = -1, readOnly = false, 
	rollbackFor = {}, noRollbackFor = {})
















